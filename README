CSE 533 : NETWORK PROGRAMMING
Assignment No: 02
------------------------------------------------------
ANKUR MITTAL (anmittal@cs.stonybrook.edu), (109176039)
GAURAV DUGAR (gdugar@cs.stonybrook.edu), (109335678)
------------------------------------------------------

1. In order to bind only to unicast addresses, we have removed the check for broadcast addresses. We get only ifi_addr value from the struct ifi_info, which always has ip address. To get broadcast address we have to check flags and get it from ifi_brdaddr, which we are NOT doing.


2. the structure used to hold the information with respect to every socket bound to each interface of server conains 4 fields.
	- sockfd (integer)
	- addr (struct in_addr)
	- ntmaddr (struct in_addr)
	- subaddr (struct in_addr)
	we create an array of such structures. subaddr is result of bitwise AND between addr and ntmaddr.


3. ANKUR MITTAL
Modify function rtt_stop (Fig. 22.13) so that it uses integer arithmetic rather than floating point. This will entail your also having to modify some of the variable and function parameter declarations throughout Section 22.5 from float to int, as appropriate.

	In the unprrt.h header file (Fig. 22.10) set :
	RTT_RXTMIN   to 1000 msec.   (1 sec. instead of the current value   3 sec.)
	RTT_RXTMAX  to 3000 msec.   (3 sec. instead of the current value 60 sec.)
	RTT_MAXNREXMT  to 12        (instead of the current value 3)

	In function rtt_timeout (Fig. 22.14), after doubling the RTO in line 86, pass its value through the function rtt_minmax of Fig. 22.11 (somewhat along the lines of what is done in line 77 of rtt_stop, Fig. 22.13).

	Finally, note that with the modification to integer calculation of the smoothed RTT and its variation, and given the small RTT values you will experience on the cs / sbpub network, these calculations should probably now be done on a millisecond or even microsecond scale (rather than in seconds, as is the case with Stevensâ€™ code). Otherwise, small measured RTTs could show up as 0 on a scale of seconds, yielding a negative result when we subtract the smoothed RTT from the measured RTT (line 72 of rtt_stop, Fig. 22.13).


4. ANKUR MITTAL
report on all the TCP mechanisms you implemented in the ReadMe file, both the ones discussed here, and the ones I will be discussing in class.
(ARQ mechanism and all others such as congestion control)


5. The clean closing and exiting is implemented as follows:
	-> The last packet coming from server will have payload of lesser size resulting in notification to of last packet. If, by chance, the last packet is full, then server sends another packet with no payload to notify the user.
	-> The client then joins the consumer thread (ensuring consumer thread to read all data before exiting).
	-> Client destroys all locks and closes the sockfd before exiting.
	-> The server after recieving the acknowledgement of last packet from client exits the child server thread.
	-> After recieving the last packet from server, the client sends the acknowledgement. Client waits for 6 seconds before exiting. (ensuring that server does not send any packet which would mean that server never recieved last ack).


OTHER SPECIFICATIONS
---------------------
- We have used spinlock on the client side sliding window, as it is being accessed and modified by main thread (while recieving packets) and consumer thread (while resetting after reading). We used ARRAY of spinlocks on each element of spinlock to improve concurrency.

- For ease of visualizing output, the code can be compiled in three ways.
	-> use "make" for all information.
	-> use "make NODEBUG=1" for viewing only the contents of file sent by user.
	-> use "make NOCONTENT=1" for viewing all information except the content of file.

- While showing the Sliding Window in client side. We show (-1), when the packet is missing. For example, if packet 13 and 15 are recieved and 14 is not recieved yet, then window will be (13, -1, 14).

- On client side, the timeout happens 10 times before exiting the program. The timers used for timeout have following values:
	-> 3 seconds (for first packet sent by timer to get port number)
	-> 40 seconds (recieving timeout in client)
	-> 6 seconds (waiting after sending last ack, to ensure that it reached server)

- We have used srand48() and drand48() to use the given seed and generate random values. we add current timestamp to the given seed to get different values everytime. drand48() gives values between 0.0 and 1.0 in double precision.

- Packet drop probability is calculated by the same means. Generating numbers between 0.0 and 1.0 and comparing the probability with that number to decide whether it should drop the packet (recieve or ack) or not.

- We have also added a check in server if:
	-> file exists or not.
	-> server has read permission on file or not.

- We have used uint64_t format for sequence numbers thus allowing us to send 2 GB file as the capacity is upto 4 million differet sequence numbers.

